# How to introduce/use MulTEx in the callable layers

The concepts behind MulTEx are described in german language 
in the technical paper `Konzepte.pdf`.

Here are given more practical instructions.

## 1. What is a MulTEx exception?

A MulTEx exception is a highly diagnostic exception
with a parameterized, internationalizable message text pattern.
In contrary the standard `Throwable` of the Java platform
does not have an internationalizable message text,
and has at most one parameter of type `String`.
MulTEx distinguishes between two kinds of exception.

Subclasses of `multex.Exc` serve as business rule exceptions,
that is they serve for specifying and implementing
the **negative** business rules.
In fact, a business rule exception represents the negation of a precondition to a method.
When specifying a method, you should specify in its **throws** clause
all exceptions, which the method can guarantee to its caller.

Subclasses of `multex.Failure` serve to indicate to the caller an unexpected failure of a method.
Typically they contain a causing exception, which occured during the method execution.
Historically earlier than the JDK 1.4, MulTEx introduced the notion of a causing exception,
which in fact results in a chain of exceptions.
As this is especially useful in layered software architectures,
MulTEx received its name.
Nowadays MulTEx even allows a `Collection` of causing exceptions,
thus spanning a causal tree.

## 2. How to declare a MulTEx exception with an internationalizable message text pattern

The most comfortable way to get an internationalizable message text pattern
associated with each exception is the following, usable from MulTEx version 7.1.

You define the message text pattern for each concrete subclass of `Throwable`
of which you have the source code.
You place the text pattern as the main comment 
into the Javadoc comment of the exception class before any @tags.
So the text pattern serves both as documentation for this exception,
and as text pattern for internationalization.

For example you could define an exception `CreditLimitExc` with a message text pattern,
expecting two message parameters, as follows.
```Java
package org.company.project;

class Account {
    ...
    /**Taking {0} units from your ac
    * count will leave less than your credit limit {1} units on it.
    */
    public static final class CreditLimitExc extends multex.Exc {}    
}
```

For `Failure`s there is no difference.
You only have to declare the exception as a subclass of `multex.Failure`.
For example in class `org.company.project.FileUtil`:
```Java
/**Failure loading file {0} by user {1}*/
public static final class LoadFileFailure extends multex.Failure {}
```
These exception declarations are so simple,
as all diagnostic information (causes and parameters)
are stored in the MulTEx base class, `Exc`, or `Failure`, respectively.
For ease of use they should be initialized using the generic `create` method
in the `MultexUtil` class, rather than the `init`-methods.
So the concrete exception class merely serves with its class name
as a key to a message text resource bundle.

## 3. Collecting the text patterns using the `ExceptionMessagesDoclet`

You can use the doclet `multex.tool.ExceptionMessagesDoclet`
to collect all exception message text patterns from the exceptions.
You must specify the sources to scan as usually for a doclet.
You must pass the output `.properties` file name to the doclet option `-out`.

By executing the doclet on the upper examples
the following property definitions will be appended to the given `-out` file:
```
org.company.project.Account$CreditLimitExc = Taking {0} units from your ac\
 count will leave less than your creditLimit {1} units on it.
org.company.project.FileUtil$LoadFileFailure = Failure loading file {0} by user {1}
```
​    As Javadoc removes white space at the end of each comment
​    line, and `java.util.Properties.load` ignores the **&bsol;**
​    indicating line continuation and whitespace at the beginning of the next line,
​    it is somehow difficult to make continuation lines with an intuitive spacing.
​    You can either split the long message text inside of a word,
​    as e.g. the word **account** in the example was split,
​    or you can insert a Properties escape sequence for whitespace
​    at the end of the line, e.g. a `\t` or a `\u0020`.

### 3.1 Example usage of the `ExceptionMessagesDoclet` from ANT
```XML
<target name="exception" depends="compile" 
  description="Collect all exception message texts into one file"
>
    
    <property name="ExceptionResourcesFile" 
        value="${CLASS_DESTINATION}/ExceptionResources.properties"
    />
    <echo file="${ExceptionResourcesFile}" append="false">
    #Generated by ANT-Target _resources. Do not edit.
multex.MsgText.causeMarker = Ursache: 
    #From here are following the message texts for the exceptions in the software system.
    #They are all collected from the main Javadoc texts of each exception declaration.
</echo>
    <javadoc
        access="private"
        classpathref="compile.classpath"
        doclet="multex.tool.ExceptionMessagesDoclet"
        docletpathref="compile.classpath"
        source="1.6"
        useexternalfile="yes"
        encoding="ISO-8859-1"
    >
        <arg value="-out"/> 
        <!--Message texts will be appended to this file.-->
        <arg file="${ExceptionResourcesFile}"/>
        
        <!--All exceptions in all Java files in this directory will be processed.-->
        <fileset dir="java"/>
    </javadoc>
</target>
```

The former example works as follows. 
The `echo` element creates a file `ExceptionResources.properties`
with a string resource for the key `multex.MsgText.causeMarker`.
This defines the german translation for the default cause marker `CAUSE:`.
Then the `multex.tool.ExceptionMessagesDoclet` appends
all exception message text patterns for all exceptions
declared in all Java files in the directory `java` to the `.properties` file.
The given encoding is used to interpret the Java source files.
For writing to the `-out` file always encoding ISO-8859-1 is used,
as `.properties` files must use it.

### 3.2 Example usage of the `ExceptionMessagesDoclet` from Maven
This works very analogous to the ANT example.
A complete example you can find in the file 
[pom.xml of the Spring DDD Bank sample application](https://github.com/christophknabe/spring-ddd-bank/blob/master/pom.xml).
There look at the [configuration of the Maven Javadoc Plugin](https://github.com/christophknabe/spring-ddd-bank/blob/master/pom.xml#L103).



## 4. How to imlement negative business rules by throwing      Exc-objects

A method should usually perform its normal specified action.
But it often has cases, which are forbidden to be handled like this.
In such situations the method should throw an `Exc` object of a specific subclass.

So typically the necessity for throwing an `Exc` can be found out by testing a precondition.
You should test one precondition after another,
always immediately throwing a specific exception.
It is understood, that these exceptions should be specified in the `throws` clause of the method,
so that the programmer of the call can consider to change the call
or to install a handler for some of them.
Here we complete the above example of the bank account .
```Java
package org.company.project;
import multex.Exc;
import static multex.MultexUtil.create;

class Account {

    final static long creditLimit = -5000;
    long balance = 0;
    
    /**Transfers the specified amount from this account 
    * to the destination account.
    * @throws CreditLimitExc the new balance of the account would become 
    * less than the creditLimit.
    */
    public void transfer(final Account destination, final long amount)
    throws CreditLimitExc 
    {
        //1. Checking for business rule violations:
        final long newBalance = balance - amount;
        if(newBalance < creditLimit){
            throw create(CreditLimitExc.class, amount, creditLimit);
        }

        //2. Performing modifications:
        balance = newBalance;
        destination.balance += amount; 
    }
    
    /**Taking {0} units from your account\t
    * will leave less than your credit limit {1} units on it.
    */
    public static final class CreditLimitExc extends Exc {}
    
}
```
Please note here, that for comfortably creating a new parameterized exception object,
as we cannot inherit parameterized constructors in Java,
we have to call the static generic factory method `MultexUtil.create`,
and pass the class of the desired exception, along with its parameters.

## 5. How to Implement Exception Chaining by Throwing a Failure Object
There are some places, where it is recommended to catch an exception,
and to wrap it into a parameterized exception with its own message text.

The first is, if the exception is a checked one,
and you don't want to specify it in the throws clause of your own method.
Then the compiler forces you to catch it.
In the catch branch you should usually wrap it.

The other is, even with an unchecked exception,
if you want to add abstraction-specific diagnostic parameters, or a message text.

We present here as an example the code for opening a serial port by means of `javax.comm`,
as was more detailedly motivated in the german text
[Ein Framework zur Ausnahmebehandlung in mehrschichtigen Softwaresystemen](Konzepte.pdf).

```Java
package x;
import multex.Exc;
import multex.Failure;
import static multex.MultexUtil.create;

class SerialPort {
    ...
    /**Opens the serial port with the given name
    * and the other communication parameters.*/
    public void open(
        String portName, int baudRate, int databits, int stopbits, int parity
    ) throws NameExc, OpenFailure {
        //1. Checking for business rule violations:
        if(!portName.startsWith("COM")){
            throw create(NameExc.class, portName);
        }

        //2. Performing modifications:
        try {
            this.portName = portName;
            final javax.comm.CommPortIdentifier portId
            = CommPortIdentifier.getPortIdentifier(portName); //NoSuchPortException
            sp = (javax.comm.SerialPort)portId.open(null,0); //PortInUseException
            sp.setSerialPortParams( baudRate, databits, stopbits, parity );
            //UnsupportedCommOperationException
            os = sp.getOutputStream(); //IOException
            is = sp.getInputStream(); //IOException
        } catch (Exception e) {
            ... //free resources
            //wrap exception and parameterize:
            throw create(OpenFailure.class, e,
                portName, baudRate, databits, stopbits, parity
            );
        } //catch
    } //open

    /**The serial port name {0} is not allowed.*/
    public static final class NameExc extends Exc {}

    /**Cannot open the serial port "{0}" with communication parameters portName
    * ={1}, baudRate={2}, databits={3}, stopbits={4}, parity={5}
    */
    public static final class OpenFailure extends Failure {}

} //SerialPort
```
Here we have the typical case,
that the whole modification part of the method body
is surrounded by a **try**-block,
in whose **catch**-branch we catch any `Exception`
and propagate it by throwing a `Failure` encapsulating the original exception
aside with diagnostic parameters.
The caught exceptions include the checked exceptions
`NoSuchPortException`, `PortInUseException`, `UnsupportedCommOperationException`, and `IOException`,
where commented and any other subclass of `java.lang.RuntimeException`.
You always have to pass the causing exception to the first parameter
of `MultexUtil.create` after the failure's class.

## 6. How to cope with many Failure causes (list exceptions, exception treeing)
There are some cases, when a Failure does not have only one cause.
This typically occurs, when processing a list of items,
each of them being necessary for the success of the complete operation.

For example we want to copy a list of files to a backup directory.
Only if we succeed to copy every file,
the whole method can be considered successful.

The first approach is
```Java
/**Copies all files from directory sourceDir to directory destDir.*/
public static void copyFiles1(final File sourceDir, final File destDir){
    try {
        final File[] files = sourceDir.listFiles();
        for(final File file: files){
            copyOneFile(file, destDir);
        }
    } catch (Exception e) {
        throw create(CopyFilesFailure1.class, sourceDir, destDir);
    }
}
```
This method `copyFiles1` succeeds only,
if all files can be successfully copied from the source directory to the destination directory.
The first failing copying of a single file will cause the abrupt termination of the complete operation.
The resulting `CopyFilesFailure` exception will have as cause only the exception of the first file copy failure.

Sometimes we need the exception of each failed single item.
For example a compiler always works like this.
It collects error messages, but goes on analyzing the source text.
The compilation will fail, if there is at least one error, but all errrors will be reported.

If we want our copy files example to handle errors like this,
we must collect the individual exceptions before creating the `CopyFilesFailure2`.
Then we can pass in this collection to the polymorphic `Object[]` parameters.
This is best done by using the constructor `Failure(String,Collection)` with a **null** String.
If we want to pass in normal message parameters, too,
as in our example `sourceDir` and `destDir`,
we should add them to the collection before the exceptions.
Then they have a fixed index usable for the message pattern.
The following example with an exception collection is a bit longer,
but gives much more diagnostic information.
```Java
/**Copies all files from directory sourceDir to directory destDir.*/
public static void copyFiles2(final File sourceDir, final File destDir){
    final Collection<Object> parameters = new ArrayList<Object>();
    parameters.add(sourceDir);
    parameters.add(destDir);
    final File[] files = sourceDir.listFiles();
    for(final File file: files){
        try {
            copyOneFile(file, destDir);
        } catch (Exception e) {
            parameters.add(e);
        }
    }
    if (parameters.size()>=2) {
        throw new CopyFilesFailure2(parameters);
    }
}

/**Failure copying files from directory {0} to directory {1}*/
public static final class CopyFilesFailure2 extends Failure {
    public CopyFilesFailure2(Collection i_parameters) {
        super((String)null, i_parameters);
    }
}
```
By the way, giving each exception the potential of a list of causing exceptions,
results in spanning a causal tree of exceptions.
The standard MulTEx services for printing an exception
will express the causal tree by indenting the lower exceptions
by a + sign for each level.

**Warning:** The standard Java services for printing an exception
(`Throwable.toString()` and `Throwable.printStackTrace`)
will ignore causal trees built like this.
So be certain, that you have installed centralized exception reporting using MulTEx services.
