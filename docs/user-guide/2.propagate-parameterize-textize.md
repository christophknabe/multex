# How to introduce/use MulTEx in the callable layers

The concepts behind MulTEx are described in german language 
in the technical paper `Konzepte.pdf`.

Here are given more practical instructions.

## What is a MulTEx exception?

A MulTEx exception is a highly diagnostic exception
with a parameterized, internationalizable message text pattern.
In contrary the standard `Throwable` of the Java platform
does not have an internationalizable message text,
and has at most one parameter of type `String`.
MulTEx distinguishes between two kinds of exception.

Subclasses of `multex.Exc` serve as business rule exceptions,
that is they serve for specifying and implementing
the **negative** business rules.
In fact, a business rule exception represents the negation of a precondition to a method.
When specifying a method, you should specify in its **throws** clause
all exceptions, which the method can guarantee to its caller.

Subclasses of `multex.Failure` serve to indicate to the caller an unexpected failure of a method.
Typically they contain a causing exception, which occured during the method execution.
Historically earlier than the JDK 1.4, MulTEx introduced the notion of a causing exception,
which in fact results in a chain of exceptions.
As this is especially useful in layered software architectures,
MulTEx received its name.
Nowadays MulTEx even allows a `Collection` of causing exceptions,
thus spanning a causal tree.

## How to declare a MulTEx exception with an internationalizable message text pattern

The most comfortable way to get an internationalizable message text pattern
associated with each exception is the following, usable from MulTEx version 7.1.

You define the message text pattern for each concrete subclass of `Throwable`
of which you have the source code.
You place the text pattern as the main comment 
into the Javadoc comment of the exception class before any @tags.
So the text pattern serves both as documentation for this exception,
and as text pattern for internationalization.

For example you could define an exception `CreditLimitExc` with a message text pattern,
expecting two message parameters, as follows.
```Java
package org.company.project;

class Account {
    ...
    /**Taking {0} units from your ac
    * count will leave less than your credit limit {1} units on it.
    */
    public static final class CreditLimitExc extends multex.Exc {}    
}
```

For `Failure`s there is no difference.
You only have to declare the exception as a subclass of `multex.Failure`.
For example in class `org.company.project.FileUtil`:
```Java
/**Failure loading file {0} by user {1}*/
public static final class LoadFileFailure extends multex.Failure {}
```
These exception declarations are so simple,
as all diagnostic information (causes and parameters)
are stored in the MulTEx base class, `Exc`, or `Failure`, respectively.
For ease of use they should be initialized using the generic `create` method
in the `MultexUtil` class, rather than the `init`-methods.
So the concrete exception class merely serves with its class name
as a key to a message text resource bundle.

## Collecting the text patterns using the `ExceptionMessagesDoclet`

You can use the doclet `multex.tool.ExceptionMessagesDoclet`
to collect all exception message text patterns from the exceptions.
You must specify the sources to scan as usually for a doclet.
You must pass the output `.properties` file name to the doclet option `-out`.

By executing the doclet on the upper examples
the following property definitions will be appended to the given `-out` file:
```
org.company.project.Account$CreditLimitExc = Taking {0} units from your ac\
 count will leave less than your creditLimit {1} units on it.
org.company.project.FileUtil$LoadFileFailure = Failure loading file {0} by user {1}
```
​    As Javadoc removes white space at the end of each comment
​    line, and `java.util.Properties.load` ignores the **&bsol;**
​    indicating line continuation and whitespace at the beginning of the next line,
​    it is somehow difficult to make continuation lines with an intuitive spacing.
​    You can either split the long message text inside of a word,
​    as e.g. the word **account** in the example was split,
​    or you can insert a Properties escape sequence for whitespace
​    at the end of the line, e.g. a `\t` or a `\u0020`.

### Example usage of the `ExceptionMessagesDoclet` from ANT
```XML
<target name="exception" depends="compile" 
  description="Collect all exception message texts into one file"
>
    
    <property name="ExceptionResourcesFile" 
        value="${CLASS_DESTINATION}/ExceptionResources.properties"
    />
    <echo file="${ExceptionResourcesFile}" append="false">
    #Generated by ANT-Target _resources. Do not edit.
multex.MsgText.causeMarker = Ursache: 
    #From here are following the message texts for the exceptions in the software system.
    #They are all collected from the main Javadoc texts of each exception declaration.
</echo>
    <javadoc
        access="private"
        classpathref="compile.classpath"
        doclet="multex.tool.ExceptionMessagesDoclet"
        docletpathref="compile.classpath"
        source="1.6"
        useexternalfile="yes"
        encoding="ISO-8859-1"
    >
        <arg value="-out"/> 
        <!--Message texts will be appended to this file.-->
        <arg file="${ExceptionResourcesFile}"/>
        
        <!--All exceptions in all Java files in this directory will be processed.-->
        <fileset dir="java"/>
    </javadoc>
</target>
```

The former example works as follows. 
The `echo` element creates a file `ExceptionResources.properties`
with a string resource for the key `multex.MsgText.causeMarker`.
This defines the german translation for the default cause marker `CAUSE:`.
Then the `multex.tool.ExceptionMessagesDoclet` appends
all exception message text patterns for all exceptions
declared in all Java files in the directory `java` to the `.properties` file.
The given encoding is used to interpret the Java source files.
For writing to the `-out` file always encoding ISO-8859-1 is used,
as `.properties` files must use it.

### Example usage of the `ExceptionMessagesDoclet` from Maven
This works very analogous to the ANT example.
A complete example you can find in the file 
[pom.xml of the Spring DDD Bank sample application](https://github.com/christophknabe/spring-ddd-bank/blob/master/pom.xml).
There look at the [configuration of the Maven Javadoc Plugin](https://github.com/christophknabe/spring-ddd-bank/blob/master/pom.xml#L103).



## How to imlement negative business rules by throwing      Exc-objects

A method should usually perform its normal specified action.
But it often has cases, which are forbidden to be handled like this.
In such situations the method should throw an `Exc` object of a specific subclass.

So typically the necessity for throwing an `Exc` can be found out by testing a precondition.
You should test one precondition after another,
always immediately throwing a specific exception.
It is understood, that these exceptions should be specified in the `throws` clause of the method,
so that the programmer of the call can consider to change the call
or to install a handler for some of them.
Here we complete the above example of the bank account .
```Java
package org.company.project;
import multex.Exc;
import static multex.MultexUtil.create;

class Account {

    final static long creditLimit = -5000;
    long balance = 0;
    
    /**Transfers the specified amount from this account 
    * to the destination account.
    * @throws CreditLimitExc the new balance of the account would become 
    * less than the creditLimit.
    */
    public void transfer(final Account destination, final long amount)
    throws CreditLimitExc 
    {
        //1. Checking for business rule violations:
        final long newBalance = balance - amount;
        if(newBalance < creditLimit){
            throw create(CreditLimitExc.class, amount, creditLimit);
        }

        //2. Performing modifications:
        balance = newBalance;
        destination.balance += amount; 
    }
    
    /**Taking {0} units from your account\t
    * will leave less than your credit limit {1} units on it.
    */
    public static final class CreditLimitExc extends Exc {}
    
}
```
Please note here, that for comfortably creating a new parameterized exception object,
as we cannot inherit parameterized constructors in Java,
we have to call the static generic factory method `MultexUtil.create`,
and pass the class of the desired exception, along with its parameters.